var fs = require('fs'),
    nodepath = require('path'),
    esprima = require('esprima'),
    YUIVersion = "3.7.0",
    http = require('http'),
    contextToV4 = '../app/',

    _conf = {
        baseDir : '../app/assets/javascripts',
        useWhiteList : true,
        filename : "auto-config-modules.js",
        targetPath : '../app/assets/javascripts',
        ignoreGallery : true
    },
// should ONLY contain actual YUI or gallery modules
    whiteList  = [],
    config = getEmptyConfig();

/**
 * main YUI_Config object, put static config objects here
 */
function getEmptyConfig() {
    return {
        filter: 'raw',
        gallery: 'gallery-2012.08.15-20-00',
        groups : {
                vk : {
                    combine: false,
                    base : '/v4/assets/javascripts', //used when combine == false
                    comboBase : '/v4/yui-combo/1?', //"/1" means version
                    root : 'javascripts',
                    modules : {}
                }
        }
        // AUTOGENERATED OBJECT, DO NOT MODIFY
    };
}
/**
 * Read global YUI, extract internal modulenames and whitelist them
 */
function readGlobalYUI(callback) {
    console.log("reading global ENV from yui.js [" + YUIVersion + "]");

    http.request({
        host : "yui.yahooapis.com",
        path : "/" + YUIVersion + "/build/yui/yui.js"

    }, function(resp){
        var _yuiRaw = "";
        resp.on('data', function(data){
            _yuiRaw += data;
        });
        resp.on('end', function(){
            whiteList = findYUIAdd(esprima.parse(_yuiRaw, {tokens : true}).body);
            setTimeout(callback, 1000);
        });

    }).end();


}

function findYUIAdd(obj) {
    var ret = [];
    var callees = obj.filter(function(o) {
        return o
            && o.expression
            && o.expression.callee
            && o.expression.callee.object
            && o.expression.callee.object.name === "YUI"
            && o.expression.callee.property
            && o.expression.callee.property.name === "add"
            && o.expression.arguments.some(function(a) {
                return a
                    && a.type
                    && a.type === "Literal"
                    && a.value
                    && a.value === "loader-yui3"
        });
    });
    try {
        callees[0].expression.arguments[1].body.body[0].expression.right.right.properties.forEach(
            function(prop) {
                ret.push(prop.key.value);
            }
        );
        return ret;
    }
    catch (ex) {
        console.log('couldnt find YUI properties for', YUIVersion);
        return null;
    }
}

/*global require, console  */
function getInnerProp(obj, key) {
    var _key = key;
    if(key.indexOf('.') !== -1) {
        var keys = key.split('.'), curObj = obj;
        keys.forEach(function(curKey){
            var curObj = getInnerProp(curObj, curKey);
        });
        return curObj;

    }
    if(obj instanceof Array){
        var ret = [];
        obj.forEach(function(item) {
            if(item.hasOwnProperty(key)) {
                ret.push(item[key]);
            }
        });
        return ret;
    }
    if(obj.hasOwnProperty(key)){
        return obj[key];
    }
    return null;
}
function replaceContext(path) {
    return path.replace(contextToV4, '/v4/');
}
function isJsFile(fileName) {
    return nodepath.extname(fileName) === ".js" && fs.statSync(fileName).isFile();
}
function isDir(name) {
    return fs.statSync(name).isDirectory();
}
function mapBasePath(obj) {
    return nodepath.join(_conf.baseDir, obj);
}
/**
 * Traverses base directory and returns all js-files and directories
 * @param base
 * @return {Object}
 */
function getAllFilesAndDirs(base) {
    var found = { dirs : [], files : []};

    var baseDirs = fs.readdirSync(_conf.baseDir).map(mapBasePath);
    baseDirs.forEach(walkTree);

    function walkTree(node) {
        if(!isDir(node)){
            if(isJsFile(node))
                found.files.push(node);
            return;
        }

        found.dirs.push(node);
        try {
            var nodePaths = fs.readdirSync(node);
            nodePaths.forEach(function(path){
                walkTree(nodepath.join(node, path));
            });
        } catch(ex) {
            console.log("couldn't walk path", node, "continuing", ex);

        }
    }
    return found;
}
function analyzeFile(fileName) {
    var fullFound = YUIConfigHelper.results.fullFound,
        entryPoints = YUIConfigHelper.results.entryPoints,
        props = EsprimaHelper.hasModule(fileName),
        fileRelativePath = fileName.replace(_conf.baseDir, "");

    // File is adding to YUI scope
    if(props && props.add) {
        if(!props.add.requires) {
            console.log("module without requires:", fileName, props.add);
        }
        fullFound.push({file : fileRelativePath, moduleName : props.add.moduleName});
        YUIConfigHelper.addToModules(
            {
                moduleName: props.add.moduleName,
                fullpath: fileRelativePath,
                requires : props.add.requires
        });
    }   // check if module is actually an entrypoint
        else if(props && props.use) {
        entryPoints.push({
            name : nodepath.basename(fileName, '.js'),
            file : replaceContext(fileName),
            usages : props.use
        });
    }
}

var EsprimaHelper = {
    isLiteral : function(item) {
        return item && item.type && item.type === "Literal";
    },
    getUsage : function(file, toText) {
        var parser = esprima.parse(file);

        if(toText) {
            return JSON.stringify(parser, undefined, 4);
        } else {
            return parser;
        }
    },
    hasModule : function(file) {
        var parse = esprima.parse(fs.readFileSync(file, 'utf-8'));

        var props = EsprimaHelper.getProperties(parse);
        if(props){
            return props;
        }

    },
    getUse : function(obj) {
        if(obj.use && obj.use.length) {
            var filtered = obj.use.filter(EsprimaHelper.isLiteral);
            return getInnerProp(filtered, 'value');
        }

    },
    getAdd : function(obj) {
        function getRequires(obj) {
            var ret = [];
            if(obj && obj.properties) {
                var requires = obj.properties.filter(function(prop){
                return prop.hasOwnProperty('key') && prop.key.hasOwnProperty('name')
                    && prop.key.name === "requires";
                });
            }
            if(requires && requires.length && requires[0].value && requires[0].value.elements) {
                requires[0].value.elements.forEach(function(require) {
                    ret.push(require.value);
                });

            }

            return ret;

        }
        if(obj.add){
            var properties = {};
            properties.moduleName = obj.add[0].value;
            properties.version = obj.add[2].value;
            properties.requires = getRequires(obj.add[3]);

            return properties;
        }

    },
    getProperties : function(obj) {
        var properties = {};

        obj.body.forEach(
            function(item){
                try {
                    var curProp = item.expression.callee.property.name,
                        curVal = item.expression.arguments;

                    properties[curProp] = curVal;
                    if(curProp === "use") {
                        properties[curProp] = EsprimaHelper.getUse(properties);
                    }
                    if(curProp === "add") {
                        properties[curProp] = EsprimaHelper.getAdd(properties);

                    }
                }
                catch(ex){
                    //console.log("object has no properties",ex);
                    return null;

                }
            });
            //console.log("module has following properties:", JSON.stringify(properties, undefined, 4));
        return properties;
    }
};
var YUIConfigHelper = {
    results : {
        fullFound : [],
        partialFound : [],
        modulesToCheck :[],
        entryPoints : []
    },
    subConfigs : [],
    _modules : [],
    addToModules : function(yuiObj) {
        if(whiteList.indexOf(yuiObj.moduleName)!== -1 || yuiObj.moduleName.indexOf('gallery') !== -1) return;
        this._modules.push(yuiObj);
        if(config.groups.vk.modules[yuiObj.moduleName]) {
            console.log("WARN: duplicate declaration for",
                yuiObj.moduleName,
                "this origin",
                yuiObj.fullpath,
                "other module",
                config.groups.vk.modules[yuiObj.moduleName]);
        }

        config.groups.vk.modules[yuiObj.moduleName] = {
            path : yuiObj.fullpath,
            requires : yuiObj.requires
        }
    },
    addSubConfigs : function() {
        var entryPoints = YUIConfigHelper.results.entryPoints,
            conf;

        entryPoints.forEach(function(entryPoint){
            conf = getEmptyConfig();
            entryPoint.usages.forEach(function(usage) {
                if(whiteList.indexOf(usage) === -1 && usage.indexOf('gallery') === -1) {
                    if(!config.groups.vk.modules[usage]){
                        console.log("WARNING, cannot find", usage, "in global config!");
                    } else {
                        config.groups.vk.modules[usage].requires.forEach(function(extUsage){
                            conf.groups.vk.modules[extUsage] = config.groups.vk.modules[extUsage];

                        });
                            conf.groups.vk.modules[usage] = config.groups.vk.modules[usage];
                    }
                }
            });
            YUIConfigHelper.subConfigs.push(conf);
        });
    },
    /**
     * Check dependencies (ie. requires array) of all found modules
     * against internal array of found modulues
     * @return {Array}
     */
    checkDependencies : function() {
        var brokenDeps = [],
            modules = this._modules;
        modules.forEach(function(module){
            module.requires.forEach(function(req){
                if(!YUIConfigHelper.moduleExists(req)) {
                    if (_conf.useWhiteList && whiteList.indexOf(req) === -1) {
                        console.log(module.moduleName, 'cant resolve', req);

                        //only add broken dependency once per failing module
                        if(brokenDeps.indexOf(req) === -1) {
                            brokenDeps.push(req);
                        }
                    }
                }
            });

        });
        return brokenDeps;
    },
    /**
     * Used to check if a required module exists in array of found modules
     * @param moduleName
     * @return {Boolean}
     */
    moduleExists : function(moduleName){
        return this._modules.some(function(module){ return module.moduleName === moduleName; });
    },
    /**
     * JSON Pretty prints module signatures with dependencies wrapped in
     * YUI_Config object in string.
     * @return {String}
     */
    logModule : function(name, config) {
        return "var YUI_config_" + name + " = " + JSON.stringify(config || getEmptyConfig(), undefined, 4) + ";\r\n";
    },
    logModules : function() {
        var string = "", i = 0;
        YUIConfigHelper.subConfigs.forEach(function(config) {
            string += YUIConfigHelper.logModule(
                YUIConfigHelper.results.entryPoints[i++].name,
                config
            );

        });
        string += YUIConfigHelper.logModule("", config);
        return string;

    },
    /**
     * Writes module config to disk
     */
    writeConfigToFile : function() {
        var data = YUIConfigHelper.logModules(),
            filename = nodepath.join(_conf.targetPath,_conf.filename);
        fs.writeFileSync(filename, data, 'utf8');
        console.log("\r\nwrote modules to", _conf.filename);

    },

    generateConfiguration : function() {

        var found = this.results.found = getAllFilesAndDirs(_conf.baseDir),
            fullFound = this.results.fullFound,
            partialFound = this.results.partialFound,
            broken = this.results.broken = YUIConfigHelper.checkDependencies(),
            modulesToCheck = this.results.modulesToCheck;

        console.log("\r\nscanning", found.dirs.length, "sub directories of",
            _conf.baseDir, "and", found.files.length, ".js files for dependencies\r\n");


        found.files.forEach(analyzeFile);

        //YUIConfigHelper.logModules();

        if (broken.length) {
            console.log("\r\nFound", broken.length,
                "references in modules with possibly broken dependencies (please whitelist if official YUI components):\r\n");
            console.log(JSON.stringify(broken, undefined, 4));
        }


        console.log("\r\nFully matched modules:", fullFound.length,
            "\r\nPartially matched modules (no requires array, or empty):",
            partialFound.length);

        var partialsToCheck = partialFound.slice(fullFound.length);
        if(partialFound.length) {
            console.log("Partials:\r\n", JSON.stringify(partialsToCheck, undefined, 4));
        }
        if(modulesToCheck.length) {
            console.log('\r\nPlease check the following files and assert that they do not contain addable YUI modules:\r\n',
                JSON.stringify(modulesToCheck, undefined, 4));
        }

    },
    run : function() {
        console.log("generate configuration...");
        YUIConfigHelper.generateConfiguration();
        console.log("add subconfigs...");
        YUIConfigHelper.addSubConfigs();

        console.log("write config to file...");
        YUIConfigHelper.writeConfigToFile();
        //console.log(whiteList);

        //YUIConfigHelper.logModules();

    }
};
// read global ENV, then run configure
readGlobalYUI(YUIConfigHelper.run);
